const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const levelLabel = document.getElementById('levelLabel');
const resetBtn = document.getElementById('resetProgress');

const TOTAL_LEVELS = 100;
const STORAGE_KEY = 'platformer_max_level';

// Input
const keys = { left: false, right: false, up: false };

window.addEventListener('keydown', e => {
  if (["ArrowLeft","KeyA"].includes(e.code)) keys.left = true;
  if (["ArrowRight","KeyD"].includes(e.code)) keys.right = true;
  if (["ArrowUp","Space","KeyW"].includes(e.code)) keys.up = true;
});
window.addEventListener('keyup', e => {
  if (["ArrowLeft","KeyA"].includes(e.code)) keys.left = false;
  if (["ArrowRight","KeyD"].includes(e.code)) keys.right = false;
  if (["ArrowUp","Space","KeyW"].includes(e.code)) keys.up = false;
});

// Player
const player = {
  x: 50, y: 0,
  w: 30, h: 30,
  vx: 0, vy: 0,
  speed: 4,
  jumpPower: 11,
  onGround: false,
  checkpoint: { x: 50, y: 350 }
};

const gravity = 0.6;
const friction = 0.8;

// Level objects
let platforms = [];
let movingPlatforms = [];
let fallingPlatforms = [];
let lava = [];
let doors = [];
let goal = {};
let currentLevel = 1;
let maxUnlockedLevel = 1;

// Save system
function loadProgress() {
  const saved = localStorage.getItem(STORAGE_KEY);
  if (saved) {
    maxUnlockedLevel = Math.min(TOTAL_LEVELS, parseInt(saved, 10) || 1);
    currentLevel = maxUnlockedLevel;
  }
}
function saveProgress() {
  localStorage.setItem(STORAGE_KEY, String(maxUnlockedLevel));
}

resetBtn.addEventListener('click', () => {
  localStorage.removeItem(STORAGE_KEY);
  maxUnlockedLevel = 1;
  currentLevel = 1;
  loadLevel(currentLevel);
});

// Procedural generator with new mechanics
function generateLevel(levelIndex) {
  const plats = [];
  const movers = [];
  const fallers = [];
  const lavaTiles = [];
  const timedDoors = [];

  // Ground
  plats.push({ x: 0, y: 400, w: 800, h: 50 });

  const difficulty = Math.min(15, Math.floor(levelIndex / 5) + 3);

  for (let i = 0; i < difficulty; i++) {
    const w = 120;
    const h = 20;
    const x = 80 + (i * (600 / difficulty));
    const y = 350 - i * 25 - (levelIndex % 7) * 4;

    // Normal platform
    plats.push({ x, y, w, h });

    // Lava under every other platform
    if (i % 2 === 1) {
      lavaTiles.push({ x, y: y + 40, w, h: 20 });
    }

    // Moving platform every 3rd
    if (i % 3 === 0) {
      movers.push({
        x, y: y - 60, w: 100, h: 20,
        startX: x, endX: x + 120,
        speed: 1.5, dir: 1
      });
    }

    // Falling platform every 4th
    if (i % 4 === 0) {
      fallers.push({
        x: x + 40, y: y - 120, w: 100, h: 20,
        triggered: false,
        fallSpeed: 0
      });
    }

    // Timed door every 5th
    if (i % 5 === 0) {
      timedDoors.push({
        x: x + 60, y: y - 80, w: 40, h: 60,
        cycle: 120, // frames
        timer: 0
      });
    }
  }

  // Goal
  const goalX = 650 + (levelIndex % 5) * 10;
  const goalY = 350 - (levelIndex % 6) * 10;

  return {
    platforms: plats,
    movingPlatforms: movers,
    fallingPlatforms: fallers,
    lava: lavaTiles,
    doors: timedDoors,
    goal: { x: goalX, y: goalY, w: 30, h: 50 },
    spawn: { x: 40, y: 350 }
  };
}

function loadLevel(levelNum) {
  const data = generateLevel(levelNum - 1);

  platforms = data.platforms;
  movingPlatforms = data.movingPlatforms;
  fallingPlatforms = data.fallingPlatforms;
  lava = data.lava;
  doors = data.doors;
  goal = data.goal;

  player.x = data.spawn.x;
  player.y = data.spawn.y;
  player.vx = 0;
  player.vy = 0;
  player.onGround = false;
  player.checkpoint = { x: player.x, y: player.y };

  levelLabel.textContent = `Level: ${levelNum} / ${TOTAL_LEVELS}`;
}

function rectIntersect(a, b) {
  return (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );
}

function update() {
  // Movement
  if (keys.left) player.vx = -player.speed;
  else if (keys.right) player.vx = player.speed;
  else player.vx *= friction;

  if (keys.up && player.onGround) {
    player.vy = -player.jumpPower;
    player.onGround = false;
  }

  player.vy += gravity;
  player.x += player.vx;
  player.y += player.vy;

  // Bounds
  if (player.x < 0) player.x = 0;
  if (player.x + player.w > canvas.width)
    player.x = canvas.width - player.w;

  if (player.y > canvas.height + 200) {
    // Respawn at checkpoint
    player.x = player.checkpoint.x;
    player.y = player.checkpoint.y;
    player.vx = 0;
    player.vy = 0;
  }

  // Moving platforms
  for (const m of movingPlatforms) {
    m.x += m.speed * m.dir;
    if (m.x > m.endX || m.x < m.startX) m.dir *= -1;
  }

  // Falling platforms
  for (const f of fallingPlatforms) {
    if (!f.triggered && rectIntersect(player, f)) {
      f.triggered = true;
      f.fallSpeed = 0;
    }
    if (f.triggered) {
      f.fallSpeed += 0.3;
      f.y += f.fallSpeed;
    }
  }

  // Timed doors
  for (const d of doors) {
    d.timer++;
    if (d.timer > d.cycle) d.timer = 0;
  }

  // Collision with all solid objects
  const solids = [
    ...platforms,
    ...movingPlatforms,
    ...fallingPlatforms,
    ...doors.filter(d => d.timer < d.cycle / 2) // door open/close
  ];

  player.onGround = false;

  for (const s of solids) {
    if (rectIntersect(player, s)) {
      const prevX = player.x - player.vx;
      const prevY = player.y - player.vy;

      if (prevY + player.h <= s.y) {
        player.y = s.y - player.h;
        player.vy = 0;
        player.onGround = true;
      } else if (prevY >= s.y + s.h) {
        player.y = s.y + s.h;
        player.vy = 0;
      } else if (prevX + player.w <= s.x) {
        player.x = s.x - player.w;
        player.vx = 0;
      } else if (prevX >= s.x + s.w) {
        player.x = s.x + s.w;
        player.vx = 0;
      }
    }
  }

  // Lava
  for (const l of lava) {
    if (rectIntersect(player, l)) {
      player.x = player.checkpoint.x;
      player.y = player.checkpoint.y;
      player.vx = 0;
      player.vy = 0;
      return;
    }
  }

  // Goal
  if (rectIntersect(player, goal)) {
    if (currentLevel < TOTAL_LEVELS) {
      currentLevel++;
      if (currentLevel > maxUnlockedLevel) {
        maxUnlockedLevel = currentLevel;
        saveProgress();
      }
      loadLevel(currentLevel);
    } else {
      alert("You beat all 100 levels!");
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#111";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#444";
  for (const p of platforms) ctx.fillRect(p.x, p.y, p.w, p.h);

  ctx.fillStyle = "#888";
  for (const m of movingPlatforms) ctx.fillRect(m.x, m.y, m.w, m.h);

  ctx.fillStyle = "#aa6";
  for (const f of fallingPlatforms) ctx.fillRect(f.x, f.y, f.w, f.h);

  ctx.fillStyle = "#0ff";
  for (const d of doors) {
    if (d.timer < d.cycle / 2) ctx.fillRect(d.x, d.y, d.w, d.h);
  }

  ctx.fillStyle = "#f30";
  for (const l of lava) ctx.fillRect(l.x, l.y, l.w, l.h);

  ctx.fillStyle = "#0f0";
  ctx.fillRect(goal.x, goal.y, goal.w, goal.h);

  ctx.fillStyle = "#4af";
  ctx.fillRect(player.x, player.y, player.w, player.h);
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loadProgress();
loadLevel(currentLevel);
loop();

